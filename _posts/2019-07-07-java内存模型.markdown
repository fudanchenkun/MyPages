# JAVA内存模型（JMM）
**并发编程模型两个关键问题**
- 通信
    - 共享内存，就是引用一个内存地址的对象，类似于全局的MAP。
    - 消息传递，实时发送同一个对象，主要是进程间通信，如元库更新加载。
- 同步 控制不同线程发生的相对顺序
    - 共享内存方式，程序员需要指定不同程序的引用顺序，因此说是显示的
    - 消息传递模型中，传递过程就已经有了顺序，因此是隐式的。

而JMM是共享内存模型。

## 内存模型

![image](6EB83BA494E6436893915D842F583BD8)

### 堆 HeapSpace
Java所有new出来的对象内存都分配到堆中。对于局部变量，如果是基本类型，会把值直接存储在栈；如果是引用类型，比如String s = new String("william");会把其对象存储在堆，而把这个对象的引用（指针）存储在栈。
分成：
年轻代
新生代（Enden区和两个Survivor区）

### 方法区（Non-heap）
也是线程共享的内存区域，存储已被虚拟机加载的**类信息**、**常量池**、**静态变量**、即时编译器编译后的代码等。

在**类加载过程**中，会对class文件进行读取，转化成二进制流信息，最后转化成**元数据信息**进行存储，包括类的全限定名称、版本、方法、字段等信息，这些在编译时就JVM就分配内存，这块区域就是方法区，对于一些常量池等等也在这里分配；在方法区也涉及到垃圾回收，比如类的卸载、无用的常量、无用的类都会回收；一般不断创建动态代理会导致方法区的oom；可以通过MaxPermSize来调节方法区的大小。

### 程序计数器
指令指示器，记录执行到哪条指令。每个程序都有一个独立的程序计数器，线程私有，主要有下面两个作用：
- 字节码解释器通过改变程序计数器来依次**读取指令**，从而实现代码的**流程控制**，如：顺序执行、选择、循环、异常处理。
- 在多线程的情况下，程序计数器用于**记录当前线程执行的位置**，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。

所以，程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**。

### Java虚拟机栈
即常说的堆栈中的“**栈**”，描述的是java方法执行的内存模型，存储局部变量、操作数栈、动态链接、方法出口等信息，包括基本类型和引用类型。

这一块区域属于线程私有的，线程要想在java虚拟机正常的运行，不仅需要计数器来记录行号，线程还需要拥有自己的运行空间，虚拟机栈可以保存方法的运行顺序，方法局部变量以及方法在运算时，需要自己的内存空间；我们把这一块区域称为虚拟机栈；每一个栈内部划分局部变量表、操作数栈、动态链表、返回地址；方法执行都需要一块区域存储局部变量，方法运算时，需要内存空间，就是操作数栈，有些方法需要运行时加载指定的方法，符号引用转化直接引用，就需要动态链表；方法遇到返回指令或者抛出异常就会返回，需要返回地址；在这一块，也会产生oom问题，典型的就是线程池没有设置大小，代码中不断创建线程，而创建线程需要内存空间，物理内存不够就会oom，遇到这样问题通常是调小栈的大小，通过Xss来设置

### 本地方法栈 
和虚拟机栈一样，在java虚拟机中，不但要执行java方法，还要执行本地（Native）方法，也会产生oom，除此之外，也会和虚拟机栈一样产生栈溢出异常


**虚拟机栈和本地方法栈为什么是私有的**?

- 虚拟机栈：每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
- 本地方法栈：和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。
 
所以，为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。

### 其他

**线程间的共享变量存储在主内存（Main Memory）**

每个线程还有个local Memory的概念，是抽象出来的，其实还是存储在缓存、写缓冲区、寄存器等硬件。

local Memory保存的是主内存的副本。

线程间的通信就是A的local Memory更新到Main Memory,B再从Main Memory拷到自己的Local Memory，这个过程由JMM来控制。

**重排序**

以优化为目的，从代码执行过程来看有，三个可以优化的地方：
- 编译器在不改变语义的情况下可以重排序某些代码，属于编译器的优化，是因为这些代码间不需要顺序执行，可以优化下方便更快地执行？
- 指令的重排序，属于处理器优化，一些指令改变顺序可以得到优化。
- 内存系统重排序，属于处理器优化，由于缓冲和读写缓冲区的存在，使得加载、存储操作可能是乱序的。

JMM要禁止一些指令的重排序，保证程序的正确执行。

**处理器的写缓冲区**
- 优点：有些程序会持续更新某些对象的值，处理器会将程序写入的数据先放在写缓冲区，再批量放入内存，这样会节省内存总线的占用。
- 缺点：每个处理器的写缓冲区只对本处理器可见。
是同一段代码，A处理器和B处理器同时处理（编译器做的优化将代码分给两个处理器，处理器再优化先做读操作再做操作，就会出问题），因此要对写读进行重排序。

**为什么要重排序**？

因为每个处理器都有自己的写缓冲区，原先写后读会浪费时间，因此要重排序，先写到缓存在读再后写到内存		（因为写操作分为两步，写到内存才算完成）

**数据依赖性**
有3个类型：写后读、写后写、读后写。
1、编译器和处理器在重排序的时候会遵守数据依赖性，不改变存在数据依赖性的两个操作。
2、第一点只在单个处理器和单个线程中有保证。

**as-if-serial**
就是说，不管怎么重排序，程序结果一定不能改变，而做法是存在数据依赖性的操作不能重排序。

**总线事物**

处理内存和处理器的之间的数据传递。
1. 所有处理器通过总线和内存交互
2. 任意时刻，只能有一个处理器访问内存。

[线程生命周期、上下文、死锁等问题](https://github.com/fudanchenkun/JavaGuide/blob/master/docs/java/Multithread/JavaConcurrencyBasicsCommonInterviewQuestionsSummary.md) 