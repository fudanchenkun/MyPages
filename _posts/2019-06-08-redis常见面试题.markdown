### 问题，为什么用redis作为缓存，不直接用map？
1. map是本地缓存，
   - 每个实例都保存一份，不具有一致性
   - 随着jvm结束而消失，不会一直保存在内存
2. 分布式缓存则可以处理好这两个问题。

### 问题：分布式缓存选择redis而不是memcached
1. redis支持多种k/v的结构，如list、set等等，而memcached只支持string
2. redis支持持久化，通过AOF或者RDB持久化到磁盘。

### redis的过期策略和淘汰算法
1. redis里面的元素可以设置过期时间，设置了过期时间的key会放到独立的字典。策略包括：
   - 定期扫描（100ms）并删除过期的key
      1. 随机找出20个key，过期的key超过1/4，则再选
      2. 扫描时间默认不超过25ms
      3. 为避免大量key在同一时间删除，可以在过期时间上加一个随机值
   - 惰性策略，客户端使用到该key时，检查是否过期
2. 过期策略还是可能因为漏掉过期的key导致内存不足，因此在写入新的key但内存不足时，启动淘汰策略，常使用的是volatile-lru和allkeys-lru，淘汰最近最不常使用的key。
3. lru算法：key放在一个链表里，最新使用的放到对头，需要删除时放到队尾。（双向链表+字典）[可以参考另外一篇](https://fudanchenkun.github.io/MyPages/2019/06/09/lru%E7%9A%84python%E5%AE%9E%E7%8E%B0.html)。
4. 从节点不做过期淘汰，主节点会在AOF上发一条删除的指令

### 为什么redis单线程还快？
- 数据都存储在内存，不会经过IO，而多线程的优势在于减少磁盘IO浪费的时间
- 非阻塞的多路复用（事件轮询，java中的NIO）
- 减少线程间的切换开销

